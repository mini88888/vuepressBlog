(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{399:function(t,a,e){"use strict";e.r(a);var s=e(52),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"关于-vue-js设计与思想-的笔记"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关于-vue-js设计与思想-的笔记"}},[t._v("#")]),t._v(" 关于[Vue.js设计与思想]的笔记")]),t._v(" "),e("h2",{attrs:{id:"框架设计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#框架设计"}},[t._v("#")]),t._v(" 框架设计")]),t._v(" "),e("h3",{attrs:{id:"框架的权衡"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#框架的权衡"}},[t._v("#")]),t._v(" 框架的权衡")]),t._v(" "),e("ol",[e("li",[t._v("命令式与声明式")])]),t._v(" "),e("p",[t._v("前端的视图层框架一般分为这两种，命令式(如：JQ)更关注过程，需要我们一步步实现过程。而声明式(Vue)更注重结果，虽然内部是命令式，但是由框架内部封装好。\n一般来说命令式的性能肯定是优于声明式：命令式如果要更改一个结果是直接更改，而声明式需要先对比差异，再去更改，所以性能消耗更多， 但是可维护性更强。\n所以对于框架设计者来说最优的是："),e("strong",[t._v("在保持可维护的同时让性能损失最小化。")])]),t._v(" "),e("h3",{attrs:{id:"框架设计的核心要素"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#框架设计的核心要素"}},[t._v("#")]),t._v(" 框架设计的核心要素")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("控制代码体积(例如区分开发环境和生产环境的输出).")])]),t._v(" "),e("li",[e("p",[t._v("良好的"),e("RouterLink",{attrs:{to:"/Vue/books/"}},[t._v("Tree-Shaking")]),t._v(": 是指清除永远不会被执行的代码 即DCE(dead code elimination);")],1)])]),t._v(" "),e("p",[e("strong",[t._v("必要满足一个条件：即模块是ESM，Tree-shaking主要依赖于ES6的模块化import和export")])]),t._v(" "),e("p",[e("strong",[t._v("一般具有以下特征：")])]),t._v(" "),e("ul",[e("li",[t._v("代码不会被执行，不可到达；")]),t._v(" "),e("li",[t._v("代码执行的结果不会被用到；")]),t._v(" "),e("li",[t._v("代码只会影响死变量（只写不读）；")])])])}),[],!1,null,null,null);a.default=r.exports}}]);